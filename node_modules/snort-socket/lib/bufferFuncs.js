/* Copyright (c) 2012 Jamie Barnes
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// $Id: bufferFuncs.js 21 2012-06-19 20:16:55Z jimbobmcgee $
 
var exports = module.exports = {};

// v0.4 did not have Buffer.readUInt(8|16|32)[BL]E, so add the ones we need here
exports.readUInt16BE = 	(Buffer.prototype.readUInt16BE !== undefined)
					 ? 	function readUInt16BE(buffer, offset) { return buffer.readUInt16BE(offset); }
					 : 	function readUInt16BE(buffer, offset) { return (buffer[offset] << 8) | buffer[offset + 1]; };
					 
exports.readUInt32LE =	(Buffer.prototype.readUInt32LE !== undefined)
					 ?	function readUInt32LE(buffer, offset) { return buffer.readUInt32LE(offset); }
					 :	function readUInt32LE(buffer, offset) { 
							return (buffer[offset + 2] << 16)
								 | (buffer[offset + 1] << 8)
								 | (buffer[offset])
								 + (buffer[offset + 3] << 24 >>> 0);
						};
						
exports.readUInt32BE =	(Buffer.prototype.readUInt32BE !== undefined)
					 ?	function readUInt32BE(buffer, offset) { return buffer.readUInt32BE(offset); }
					 :	function readUInt32BE(buffer, offset) { 
							return (buffer[offset + 1] << 16)
								 | (buffer[offset + 2] << 8)
								 | (buffer[offset + 3])
								 + (buffer[offset] << 24 >>> 0);
						};						
						
// additional functions for reading an IP address from a network packet (always big-endian)
exports.readIPv4Address =	function readIPv4Address(buffer, offset) {
								var a = [], b;
								for (b = 0; b < 4; b++) {
									a.push(buffer[offset + b]);
								}
								return a.join('.');
							};

exports.readIPv6Address =	function readIPv6Address(buffer, offset) {
								var a = [], b, x;
								for (b = 0; b < 16; b++) {
									x = buffer[offset + b].toString(16);
									a.push(
										x.length === 1 ? '0' : '', 			// ensure 2-digit hex for 0x0-0xF
										x, 
										(b < 15 && b % 2 === 1) ? ':' : ''	// every two bytes, add colon separator
									);
								}
								return a.join('');
							};