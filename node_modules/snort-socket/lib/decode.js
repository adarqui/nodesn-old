/* Copyright (c) 2012 Jamie Barnes
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// $Id: decode.js 22 2012-06-19 21:54:09Z jimbobmcgee $
 
var bufferFuncs = require('./bufferFuncs.js');

function Alert() { }; 
Alert.constructor = Alert;
Alert.prototype = { 
	message: null,
	protocol: { 
		ip: null, 
		id: null, 
		name: null, 
		fields: null 
	},
	source: { 
		address: null, 
		port: null 
	},
	destination: { 
		address: null, 
		port: null 
	},
	event: { 
		id: null, 
		ref: null, 
		class: null, 
		priority: null, 
		timestamp: { 
			seconds: null, 
			micros: null, 
			date: null 
		},
		signature: { 
			generator: null, 
			id: null, 
			revision: null 
		} 
	}
};

var exports = module.exports = {};

exports.getDecoder = function getDecoder(options) {
	if (options === undefined || 
		options === null || 
		options.debug === undefined ||
		options.debug === null ||
		options.debug.constructor !== Boolean ||
		options.bigEndian === undefined ||
		options.bigEndian === null ||
		options.bigEndian.constructor !== Boolean ||
		options.alertMessageLength === undefined ||
		options.alertMessageLength === null ||
		options.alertMessageLength.constructor !== Number ||
		options.snapshotLength === undefined ||
		options.snapshotLength === null ||
		options.snapshotLength.constructor !== Number) {
		throw new Error(['options: expected Object { debug: Boolean, bigEndian: Boolean, ',
						 'alertMessageLength: Number, snapshotLength: Number }'].join(''));
	}
	
	// ref: /snort/src/spo_alert_unixsock.h -> http://www.koders.com/c/fid7ED2B7276BC8A8C9ACC23CD5F9F963B9B168AFFB.aspx	
	var expectedLength = (
		  (1 * options.alertMessageLength) 		// u_int8_t alertmsg[ALERTMSG_LENGTH]
		+ 16 									// struct pcap_pkthdr
		+ 16 									// u_int32_t dlthdr, u_int32_t nethdr, u_int32_t transhdr, u_int32_t data
		+ 4 									// u_int32_t val
		+ (1 * options.snapshotLength) 			// u_int8_t pkt[SNAPLEN / 65535]
		+ 36									// Event event (from snort/src/event.h)
	);
/*
	var expectedLength = {
		(1 * options.alertMessageLength)
		+ 16
		+ 32
		+ 32
		+ 
*/

	// load the correct debug writer function, depending on debug state
	var __dbg = require('./debug.js').getWriter('decode.js', options);

	// use the readUInt32 function with the requested endianness
	var readUInt32 = !!options.bigEndian ? bufferFuncs.readUInt32BE : bufferFuncs.readUInt32LE;
	
	return function decode(data) {
		if (data === undefined || data === null || !Buffer.isBuffer(data)) {
			throw new Error('decode: expected parameter data: Buffer');
		}
		
/*
		__dbg('        data.length = ', data.length);		
		if (data.length !== expectedLength) {
			console.log("error", data, expectedLength, data.length);
		}
		else
*/

console.log("error", data, expectedLength, data.length);

 {
			// ref: /snort/src/spo_alert_unixsock.h -> http://www.koders.com/c/fid7ED2B7276BC8A8C9ACC23CD5F9F963B9B168AFFB.aspx	
			var dataPos = 0;
			var alertMessage	= data.slice(dataPos, dataPos += options.alertMessageLength);
			var pcapHeader 		= data.slice(dataPos, dataPos += 16);
			var offsetInfo 		= data.slice(dataPos, dataPos += 16);
			var flags 			= readUInt32(data, dataPos); dataPos += 4;
			var snapshot 		= data.slice(dataPos, dataPos += options.snapshotLength);
			var event 			= data.slice(dataPos, dataPos += 36);

			__dbg('alertMessage.length = ', alertMessage.length);
			__dbg('  pcapHeader.length = ', pcapHeader.length);
			__dbg('  offsetInfo.length = ', offsetInfo.length);
			__dbg('    snapshot.length = ', snapshot.length);
			__dbg('       event.length = ', event.length);
			

			// read the message from the datagram	
			var decoded = new Alert();	
			decoded.message = ('' + alertMessage).substring(0, ('' + alertMessage).indexOf('\0'));

console.log("h", flags & 0x1, "offsetinfo", offsetInfo, "event", event);
console.log("FUCK1", decoded);
flags = 1;

util = require("util");
console.log(util.inspect(decoded));

//return true;

			// read the packet header from the snapshot
//			if ((flags & 0x1) !== 0x1) {	// NO_PACKET_STRUCT = 0x1 -> if 0x1, there is no packet header
if(flags == 1) {
				var ethernetFrameStart = readUInt32(offsetInfo, 4);

console.log("FUCK2", ethernetFrameStart);

				if (ethernetFrameStart > 0) {
					// ref: http://www.networksorcery.com/enp/protocol/ip.htm
					var ip = decoded.protocol.ip = (snapshot[ethernetFrameStart] >> 4) & 0x0F;		// returns 4 for IPv4 and 6 for IPv6

console.log("FUCK3", ip, decoded, decoded.protocol);
				
					if (ip === 4) {
						// ref: http://www.networksorcery.com/enp/protocol/ip.htm
						decoded.source.address = bufferFuncs.readIPv4Address(snapshot, ethernetFrameStart + 12);
						decoded.destination.address = bufferFuncs.readIPv4Address(snapshot, ethernetFrameStart + 16);
						decoded.protocol.id = snapshot[ethernetFrameStart + 9];
					}
					else if (ip === 6) {
						// ref: http://www.networksorcery.com/enp/protocol/ipv6.htm
						decoded.source.address = bufferFuncs.readIPv6Address(snapshot, ethernetFrameStart + 8);
						decoded.destination.address = bufferFuncs.readIPv6Address(snapshot, ethernetFrameStart + 12);
						decoded.protocol.id = snapshot[ethernetFrameStart + 6];
					}
				
					// ref: http://www.networksorcery.com/enp/protocol/ip.htm#Protocol
					decoded.protocol.name = (decoded.protocol.id === 1)	 ? 'icmp' :
											(decoded.protocol.id === 2)	 ? 'igmp' :
											(decoded.protocol.id === 6)	 ? 'tcp' :
											(decoded.protocol.id === 17) ? 'udp' :
											(decoded.protocol.id === 58) ? 'icmp6/mld' :
											null;
				}
			}
		
			// read the protocol data from the snapshot
			if ((flags & 0x2) !== 0x2) {	// NO_TRANSHDR = 0x2 -> if 0x2, there is no transport frame
				var transportFrameStart = readUInt32(offsetInfo, 8);
				if (transportFrameStart > 0) {
					switch (decoded.protocol.name) {
						case 'tcp':		// ref: http://www.networksorcery.com/enp/protocol/tcp.htm
						case 'udp':	{	// ref: http://www.networksorcery.com/enp/protocol/udp.htm
							decoded.source.port			= snapshot.readUInt16BE(transportFrameStart);
							decoded.destination.port	= snapshot.readUInt16BE(transportFrameStart + 2);
							break;
						}
						
						case 'icmp':
						case 'icmp6/mld':
						case 'igmp':
						default: {
							// TODO: get some of the protocol-specific fields and add to the 
							//		 decoded.protocol.fields object
							break;
						}
					}
				}
			}
			
			// read the event data from the dgram
			// ref: snort/src/event.h -> http://www.koders.com/c/fid04A17F18BE09781FBC61529FAD0F974279C91CFC.aspx
			var eventPos;
			decoded.event.signature.generator = readUInt32(event, eventPos	= 0);	// u_int32_t sig_generator
			decoded.event.signature.id		  = readUInt32(event, eventPos += 4);	// u_int32_t sig_id
			decoded.event.signature.revision  = readUInt32(event, eventPos += 4);	// u_int32_t sig_rev
			decoded.event.class				  = readUInt32(event, eventPos += 4);	// u_int32_t classification
			decoded.event.priority			  = readUInt32(event, eventPos += 4);	// u_int32_t priority
			decoded.event.id				  = readUInt32(event, eventPos += 4);	// u_int32_t event_id
			decoded.event.ref				  = readUInt32(event, eventPos += 4);	// u_int32_t event_reference
			
			decoded.event.timestamp.seconds	  = readUInt32(event, eventPos += 4);	// struct timeval ref_time
			decoded.event.timestamp.micros	  = readUInt32(event, eventPos += 4);	
			
			// interpret 'seconds' value as seconds since 01-Jan-1970, so convert seconds+microsecond to 
			// milliseconds for use in standard Date constructor
			decoded.event.timestamp.date = new Date(
				(decoded.event.timestamp.seconds * 1000) +
				Math.floor(decoded.event.timestamp.micros / 1000)
			);
			
			return decoded;
		}
	};
};
