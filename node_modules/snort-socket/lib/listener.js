/* Copyright (c) 2012 Jamie Barnes
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// $Id: listener.js 22 2012-06-19 21:54:09Z jimbobmcgee $
 
var util = require('util');
var fs = require('fs');
var path = require('path');
var events = require('events');

var defaultOptions = {
	debug: 				false,
	bigEndian: 			false,
	forceUnixDgram: 	false,
	alertMessageLength:	256,
	snapshotLength:		65536
};

// var x = new SnortSocket(socketPath, [options]);
function SnortSocket(options) {
	events.EventEmitter.call(this);
	var self = this;

	// apply defaults
	options = options || {};
	for (var d in defaultOptions) {
		if (defaultOptions.hasOwnProperty(d) && !options.hasOwnProperty(d)) {
			options[d] = defaultOptions[d];
		};
	}
	
	// mixin the subfiles for this project
	var decode	= require('./decode.js').getDecoder(options);
	var __dbg	= require('./debug.js').getWriter('listener.js', options);
	
	__dbg('created with options: ', options);
	
	// dynamically mixin unix-dgram module, for v0.5+ or if forced
	var dgramModule	= (process.version < 'v0.5' && !options.forceUnixDgram) ? 'dgram' : 'unix-dgram';
	__dbg('loading dgram code from ', dgramModule);
	var dgram = require(dgramModule);
	
	var bound = false;
	var socket = null;
	
	///////////////////////////////////////////////////////////////////////////////////////////////
		
	var bindSocket = function bindSocket(socketPath, callback) {
		if (socket === null) {
			socket = dgram.createSocket('unix_dgram');
		
			var bindSocketResult = function bindSocketResult(err) {
				if (!!err) {
					if (!!bound) callback(err);
					else 		 onSocketError(err);
				}
				else {
					bound = true;
					this.once('listening', callback);
					onSocketListening();
				}
			};
		
			socket.on('listening',	bindSocketResult);
			socket.on('error',		bindSocketResult);		
			socket.on('message', 	onSocketMessage);
			socket.on('close', 		onSocketClose);
			
			socket.bind(socketPath);
		}
		else callback(new Error('bind: already bound'));
	};
	
	var onSocketListening = 	function onSocketListening() {
									__dbg('listening for messages on socketPath');	
									self.emit('listening');
								};
	
	var onSocketMessage = 		function onSocketMessage(data) {
									__dbg('data received...decoding');
									try {
										var decodedAlert = decode(data);
										__dbg('data received...decoded: ', decodedAlert);
										self.emit('alert', decodedAlert);
									}
									catch (err) {
										self.emit('error', err);
									}
								};

	var onSocketError = 		function onSocketError(err) {
									__dbg('ERROR: received error ', err, '\r\nat :', err.stack);
									self.emit('error', err);
								};

	var onSocketClose = 		function onSocketClosed(didError) {
									__dbg('closed socket', !!didError ? ' due to error' : '');
									socket = null;
									bound = false;
									this.socketPath = '';
									
									self.emit('close', didError);
								};
	
	///////////////////////////////////////////////////////////////////////////////////////////////
	
	this.socketPath = '';
	
	// snortSocket.bind('/path/to/socket', func(err) { });
	this.bind = function(socketPath, callback) {
		callback = (callback !== undefined && 
				callback !== null && 
				callback.constructor === Function) ? callback : function noop() { };

		if (socketPath === undefined || socketPath === null || socketPath.constructor !== String || socketPath.length === 0) {
			callback(new Error('socketPath: expected non-empty string'));
		}	
		else path.exists(socketPath, function socketPathExists(exists) {
			if (!!exists) fs.unlink(socketPath, function socketPathUnlink(err) {	// delete the existing file
				if (!!err) {
					__dbg('ERROR: could not unlink/delete existing socket file: ', err, '\r\nat :', err.stack);
					callback(err);
				}
				else bindSocket(socketPath, callback);
			});
			else bindSocket(socketPath, callback);
		});
	};
	
	this.close = function(callback) {
		callback = (callback !== undefined && 
					callback !== null && 
					callback.constructor === Function) ? callback : function noop() { };
		
		if (socket !== null) {
			this.once('close', function explicitClose() { callback(); });
			socket.close();
		}
	};
}
util.inherits(SnortSocket, events.EventEmitter);

var exports = module.exports = {};
exports.SnortSocket = SnortSocket;